FROM node:16

WORKDIR /app
# 컨테이너 파일 시스템 내의 특정 디렉토리
# 모든 컨테이너에는 자체 파일 시스템이 있음, 작업하고자 하는 특별한 디렉토리

COPY package.json .
# package.json 파일을 작업하려는 디렉토리에 복사한다

RUN npm install

COPY . .
# 나머지 코드도 디렉토리에 복사

EXPOSE 3000
# port 설정
# 컨테이너 내부 뿐만 아니라 컨테이너 외부에서 해당 포트에 도달할 수 있도록 한다.
# 즉 이 NodeJS 앱은 3000번 포트에서 들어오는 요청을 수신 대기하는 웹 서버를 생성함

CMD [ "node", "app.mjs" ]
# node 명령어로 해당 파일 실행

# NodeJS를 기본 이미지로 사용하는 방법
# 컨테이너 내부에서 NodeJS를 사용할 수 있다

# Docker Hub에서 Node 환경을 다운로드하고, 이미지 내부에서 실행되는 
# 이러한 설정으로 시작되는 컨테이너의 이미지 설정
# 즉 컨테이너로 시작될 준비가 된 이미지 생성

# 윈도우 환경의 경우 만들어진 이미지 ID는 마지막 줄
# writing image sha256:'c016e3aa550a86b7603849af7fd00d603e4d6b79834ff38a2d7759019c9571f6' -> 이부분

# 해당 이미지 기반 컨테이너 실행 명령어 docker run ID
# 이 컨테이너는 통신하려는 포트 3000이 있기 때문에 실제로 실행하려는 컨테이너에
# 해당 포트를 publish 해야함
# docker run -p 3000:3000 -> 포트3000에 포트 3000 게시
# 로컬 시스템의 로컬 호스트를 사용하여 컨테이너 대신 포트 3000에서 실행되는 앱에 연결 가능
# 컨테이너와 호스트 운영체제 사이에는 디폴트 연결이 없기 때문
# 예를 들어, 컨테이너에서 실행중인 애플리케이션에 Http 요청을 보내려면
# 통신하려는 컨테이너의 포트를 열어야한다. 
# 안 그러면 컨테이너에 잠긴네트워크 이므로 외부에서 연결할 수 없다

# docker를 종료하려면 새 터미널을 열어서 docker ps
# 실행중인 모든 컨테이너가 나열되는데, 시작된 컨테이너의 이름을 가져옴(자동 할당)
# docker stop 컨테이너 이름

# 일일이 설치하지 않아도 실행가능하다!